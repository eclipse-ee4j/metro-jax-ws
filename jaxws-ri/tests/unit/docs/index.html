<!--

    Copyright (c) 1997, 2020 Oracle and/or its affiliates. All rights reserved.

    This program and the accompanying materials are made available under the
    terms of the Eclipse Distribution License v. 1.0, which is available at
    http://www.eclipse.org/org/documents/edl-v10.php.

    SPDX-License-Identifier: BSD-3-Clause

-->

<html xmlns:d="jelly:define" xmlns:jsl="jelly:jsl" xmlns:j="jelly:core" xmlns:l="layout" xmlns:x="jelly:xml" xmlns:jsl="jelly:jsl" xmlns:j="jelly:core" xmlns:d="jelly:define" xmlns:x="jelly:xml" xmlns:l="layout">
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=iso-8859-1"> 
    <title>Metro Test Harness User Guide</title> 
    <style>
    H1 {
      text-align: center;
    }
    
    PRE.cmd { /* command line example */
      background-color: #eee;
      border: solid 1px gray;
      font-weight: bold;
      padding: 0.2em;
    }
    
    PRE.script { /* script example */
      background-color: #efe;
      border: solid 1px darkgreen;
      font-weight: bold;
      padding: 0.2em;
    }
    
    PRE.dir { /* directory layout */
      padding: 0.2em;
      align: center;
    }
    
    DIV.tip {
      padding: 0.2em;
      margin: 1em;
      margin-left: 3em;
      border: 1px dashed black;
      background-color: #ddf;
    }
  </style> 
  </head> 
  <body>         
    <h1>JAX-WS/Tango Test Harness User Guide</h1> 
    <div align="right">$Id: index.html,v 1.47 2010-07-21 18:31:28 ramapulavarthi Exp $</div>      
    <h2>Table of contents</h2> 
    <ol>             
      <li>
        <a href="#Running_Tests">Running Tests</a>
      </li> 
      <ol>   
        <li>
          <a href="#Configuring_the_Harness_Classpath_for_Different_Delivery_Vehicles">Configuring the Harness Classpath for Different Delivery Vehicles</a>
        </li> 
        <ol>   
          <li>
            <a href="#JAX_WS_RI_Workspace">JAX-WS RI Workspace</a>
          </li> 
          <ol> </ol>    
          <li>
            <a href="#JAX_WS_RI_Binary_Image">JAX-WS RI Binary Image</a>
          </li> 
          <ol> </ol>    
          <li>
            <a href="#WSIT_Workspace">WSIT Workspace</a>
          </li> 
          <ol> </ol>    
          <li>
            <a href="#WSIT_Binary_Image">WSIT Binary Image</a>
          </li> 
          <ol> </ol>    
          <li>
            <a href="#Overriding_jars">Overriding jars</a>
          </li> 
          <ol> </ol>  
        </ol>    
        <li>
          <a href="#Running_Tests_Manually">Running Tests Manually</a>
        </li> 
        <ol> </ol>    
        <li>
          <a href="#Debugging_Test_Failures">Debugging Test Failures</a>
        </li> 
        <ol>   
          <li>
            <a href="#Looking_Inside_Working_Directory">Looking Inside Working Directory</a>
          </li> 
          <ol> </ol>  
        </ol>    
        <li>
          <a href="#Testing_Different_Transports_Containers">Testing Different Transports/Containers</a>
        </li> 
        <ol>   
          <li>
            <a href="#In_VM__No_Container_">In-VM (No Container)</a>
          </li> 
          <ol> </ol>    
          <li>
            <a href="#Tomcat">Tomcat</a>
          </li> 
          <ol>   
            <li>
              <a href="#Embedded_Tomcat">Embedded Tomcat</a>
            </li> 
            <ol> </ol>    
            <li>
              <a href="#Remote_Tomcat">Remote Tomcat</a>
            </li> 
            <ol> </ol>    
            <li>
              <a href="#Local_Tomcat">Local Tomcat</a>
            </li> 
            <ol> </ol>  
          </ol>    
          <li>
            <a href="#Jetty">Jetty</a>
          </li> 
          <ol>   
            <li>
              <a href="#Embedded_Jetty">Embedded Jetty</a>
            </li> 
            <ol> </ol>  
          </ol>    
          <li>
            <a href="#Glassfish">Glassfish</a>
          </li> 
          <ol>   
            <li>
              <a href="#Remote_Glassfish">Remote Glassfish</a>
            </li> 
            <ol> </ol>    
            <li>
              <a href="#Local_Glassfish">Local Glassfish</a>
            </li> 
            <ol> </ol>  
          </ol>  
        </ol>    
        <li>
          <a href="#Running_Batch_Tests">Running Batch Tests</a>
        </li> 
        <ol> </ol>    
        <li>
          <a href="#Summarizing_Test_Results">Summarizing Test Results</a>
        </li> 
        <ol> </ol>    
        <li>
          <a href="#Generating_Coverage_Report">Generating Coverage Report</a>
        </li> 
        <ol> </ol>  
      </ol>                
      <li>
        <a href="#Writing_Tests">Writing Tests</a>
      </li> 
      <ol>   
        <li>
          <a href="#Conventions">Conventions</a>
        </li> 
        <ol> </ol>    
        <li>
          <a href="#Test_Descriptor">Test Descriptor</a>
        </li> 
        <ol>   
          <li>
            <a href="#Linking_to_Relevant_Bugs">Linking to Relevant Bugs</a>
          </li> 
          <ol> </ol>    
          <li>
            <a href="#Specifying_test_requirements_from_the_Container">Specifying test requirements from the Container</a>
          </li> 
          <ol> </ol>    
          <li>
            <a href="#Specifying_verbatim_wsimport_options">Specifying verbatim wsimport options</a>
          </li> 
          <ol> </ol>    
          <li>
            <a href="#Specifying_test_specific_options">Specifying test specific options</a>
          </li> 
          <ol> </ol>  
        </ol>    
        <li>
          <a href="#Client_Test_Scripts">Client Test Scripts</a>
        </li> 
        <ol>   
          <li>
            <a href="#Invoking_Services">Invoking Services</a>
          </li> 
          <ol> </ol>    
          <li>
            <a href="#More_on_Script_Execution_Environment">More on Script Execution Environment</a>
          </li> 
          <ol> </ol>    
          <li>
            <a href="#Common_utility">Common utility</a>
          </li> 
          <ol> </ol>    
          <li>
            <a href="#Side_effect_free_tests">Side-effect free tests</a>
          </li> 
          <ol> </ol>  
        </ol>    
        <li>
          <a href="#Java_Client">Java Client</a>
        </li> 
        <ol> </ol>    
        <li>
          <a href="#Service">Service</a>
        </li> 
        <ol>   
          <li>
            <a href="#WSDL">WSDL</a>
          </li> 
          <ol> </ol>  
        </ol>    
        <li>
          <a href="#Requiring_certain_modes">Requiring certain modes</a>
        </li> 
        <ol> </ol>    
        <li>
          <a href="#Resources">Resources</a>
        </li> 
        <ol> </ol>    
        <li>
          <a href="#Common_source_files">Common source files</a>
        </li> 
        <ol> </ol>  
      </ol>                
      <li>
        <a href="#Technical_Assistance">Technical Assistance</a>
      </li> 
      <ol> </ol>        
    </ol>          
    <a name="Running_Tests"></a>
    <h2>
      <a name="Running_Tests">
        <a href="#Running_Tests">1.</a>  Running Tests
      </a>
    </h2>           
    <a name="Configuring_the_Harness_Classpath_for_Different_Delivery_Vehicles"></a>
    <h3>
      <a name="Configuring_the_Harness_Classpath_for_Different_Delivery_Vehicles">
        <a href="#Configuring_the_Harness_Classpath_for_Different_Delivery_Vehicles">1.1.</a>  Configuring the Harness Classpath for Different Delivery Vehicles
      </a>
    </h3>   
    <p>The harness can be used to test different projects that use the JAX-WS RI. Normally,
      <b>the harness will be able to automatically guess which project you are working on, and set up classpath automatically</b>. However, you can always use one of the following options to manually specify it to override this default behavior.
             
    <a name="JAX_WS_RI_Workspace"></a>
    <h4>
      <a name="JAX_WS_RI_Workspace">
        <a href="#JAX_WS_RI_Workspace">1.1.1.</a>  JAX-WS RI Workspace
      </a>
    </h4>   
    <p>The following option tells the harness to pick up the JAX-WS RI classes from the JAX-WS workspace. Specifically, with this option, the harness will look into various
      <tt>build/classes</tt> and library jars.
      
    <pre class="cmd">$ java -jar path/to/harness.jar -cp:jaxws path/to/jaxws-ri-workspace test-dir1 test-dir2 ...</pre>               
    <a name="JAX_WS_RI_Binary_Image"></a>
    <h4>
      <a name="JAX_WS_RI_Binary_Image">
        <a href="#JAX_WS_RI_Binary_Image">1.1.2.</a>  JAX-WS RI Binary Image
      </a>
    </h4>   
    <p>The following option tells the harness to pick up the RI classes from a JAX-WS binary dist image. Using this option, the harness will only look at the RI library jars found under the
      <TT>lib</TT> directory of the top-level dist image directory that you specify.
      
    <pre class="cmd">$ java -jar path/to/harness.jar -cp:jaxws-image path/to/jaxws-ri-image test-dir1 test-dir2 ...</pre>               
    <a name="WSIT_Workspace"></a>
    <h4>
      <a name="WSIT_Workspace">
        <a href="#WSIT_Workspace">1.1.3.</a>  WSIT Workspace
      </a>
    </h4>   
    <p>The following option tells the harness to pick up the WSIT classes from a WSIT workspace. Specifically, with this option, the harness will look into various
      <tt>build/classes</tt> and library jars.
      
    <pre class="cmd">$ java -jar path/to/harness.jar <span style="color:red; font-weight:bold">-cp:wsit path/to/wsit-workspace</span> test-dir1 test-dir2 ...</pre>               
    <a name="WSIT_Binary_Image"></a>
    <h4>
      <a name="WSIT_Binary_Image">
        <a href="#WSIT_Binary_Image">1.1.4.</a>  WSIT Binary Image
      </a>
    </h4>   
    <p>The following option tells the harness to pick up the WSIT classes from a binary dist image. Using this option, the harness will only look at the WSIT library jars (webservices.jar &amp; webservices-tools.jar) found under the
      <TT>lib</TT> directory of the dist image directory that you specify.
      
    <pre class="cmd">$ java -jar path/to/harness.jar -cp:wsit-image path/to/wsit-image test-dir1 test-dir2 ...</pre>               
    <a name="Overriding_jars"></a>
    <h4>
      <a name="Overriding_jars">
        <a href="#Overriding_jars">1.1.5.</a>  Overriding jars
      </a>
    </h4>   
    <p>Sometimes it's convenient to be able to override some of the test subject jars with an override (like applying a patch.) You can use
      <tt>-cp:override</tt> option to do this.
                      
    <a name="Running_Tests_Manually"></a>
    <h3>
      <a name="Running_Tests_Manually">
        <a href="#Running_Tests_Manually">1.2.</a>  Running Tests Manually
      </a>
    </h3>   
    <p>Each test is packaged in a directory. The following command runs a single test stored in
      <tt>testdata/abc/def</tt>:
      
    <pre class="cmd">$ java -jar path/to/harness.jar testdata/abc/def</pre>  
    <p>If you specify multiple directories, all the tests in the specified directories are run.  
    <pre class="cmd">$ java -jar path/to/harness.jar testdata/abc/*</pre>  
    <p>The
      <tt>-r</tt> option tells the harness to recursively search for all tests inside the given directory:
      
    <pre class="cmd">$ java -jar path/to/harness.jar -r testdata/addressing</pre>   
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> Consider defining an alias to
            <tt>java -jar path/to/harness.jar</tt> or a wrapper shell script so that you don't have to type the path name manually. 
          </td> 
        </tr>
      </table> 
    </div>               
    <a name="Debugging_Test_Failures"></a>
    <h3>
      <a name="Debugging_Test_Failures">
        <a href="#Debugging_Test_Failures">1.3.</a>  Debugging Test Failures
      </a>
    </h3>   
    <p>The following command executes a test with debugger support enabled. Run this command from a console, then set up a remote debugging with your IDE to port 8000. This allows you to set breakpoints anywhere both on the client and the server.  
    <pre class="cmd">$ java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000 -jar path/to/harness.jar testdata/abc/def</pre>   
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> You'll use this command very often, so consider defining an alias to
            <tt>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000 -jar path/to/harness.jar</tt>  
          </td> 
        </tr>
      </table> 
    </div>  
    <p>If your test data resides in the Tango workspace or the JAX-WS workspace, the harness recognizes their directory layouts and pick up classes from respective
      <tt>build/class</tt> directories and libraries. So if you make a change to the source code, all you need to do is to compile them to class files.
      
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> Do not run any targets that generate jar files, as those unnecessary work will slow you down. </td> 
        </tr>
      </table> 
    </div>  
    <p>If your change to the code is to the runtime and does not affect the code generation, then use the
      <tt>-skip</tt> option to skip the code generation. This allows you to quickly rerun the runtime portion of the tests without wasting time running all the tools just to produce the same results.
      
    <pre class="cmd">$ java -jar path/to/harness.jar -skip testdata/abc/def</pre>          
    <a name="Looking_Inside_Working_Directory"></a>
    <h4>
      <a name="Looking_Inside_Working_Directory">
        <a href="#Looking_Inside_Working_Directory">1.3.1.</a>  Looking Inside Working Directory
      </a>
    </h4>   
    <p>The test harness leaves all the artifacts generated during a test execution inside a working directory called
      <tt>work</tt> in each test directory. Sometimes inspecting what's generated becomes important, so this is the directory structure of the work directory:
      <pre class="dir">
work/                    (root test directory)
 +- client-source/       (client Java artifacts generated by wsimport from service WSDL)
 +- client-classes/      (compiled client Java artifacts. Generated from client-source by Javac)
 +- services
     +- &lt;serviceName&gt;    (this intermediate directory is only if you have multiple services)
         +- war          (root of the exploded war file image that's deployed to the server)
         +- gen-src      (generated server Java artifacts by wsimport)
</pre> 
    
    <p>Unless the
      <tt>-skip</tt> option is used, the work directory is
      <tt>"rm -rf"</tt>ed before a test execution. There's no need to manually remove them.
                      
    <a name="Testing_Different_Transports_Containers"></a>
    <h3>
      <a name="Testing_Different_Transports_Containers">
        <a href="#Testing_Different_Transports_Containers">1.4.</a>  Testing Different Transports/Containers
      </a>
    </h3>   
    <p>The harness can run tests by using a variety of transports and containers.         
    <a name="In_VM__No_Container_"></a>
    <h4>
      <a name="In_VM__No_Container_">
        <a href="#In_VM__No_Container_">1.4.1.</a>  In-VM (No Container)
      </a>
    </h4>   
    <p>By default, the test harness uses the in-vm transport. There's no additional option required for this mode. This is the preferred mode of testing because of its quick turn-around time. This mode also allows you to use a single debug session to debug both the client and the server side. 
    <p>Some delivery vehicles (notably the distribution images) do not have the code needed to use the in-vm transport. To test those, find the matching
      <tt>jaxws-local-transport.jar</tt> and use the
      <tt>-transport</tt> option to specify it.
      
    <pre class="cmd">$ java -jar path/to/harness.jar -cp:wsit-image path/to/wsit -transport path/to/jaxws-local-transport.jar ...</pre>               
    <a name="Tomcat"></a>
    <h4>
      <a name="Tomcat">
        <a href="#Tomcat">1.4.2.</a>  Tomcat
      </a>
    </h4>   
    <p>This test harness supports Tomcat 5.0.x or 5.5.x. There are a few different ways of using Tomcat.         
    <a name="Embedded_Tomcat"></a>
    <h5>
      <a name="Embedded_Tomcat">
        <a href="#Embedded_Tomcat">1.4.2.1.</a>  Embedded Tomcat
      </a>
    </h5>   
    <p>The following command causes the harness to run Tomcat within the same VM. This mode is bit like the local transport, in the sense that both the server and the client runs inside the same VM, but this mode run tests by using HTTP and full servlet container.  
    <pre class="cmd">$ java -jar path/to/harness.jar -tomcat-embedded path/to/tomcat test-dir1 test-dir2 ...</pre>  
    <p>
      <tt>path/to/tomcat</tt> should point to the directory where you have Tomcat installed. The harness will load Tomcat jar files from there.
    
    <p>This mode is preferrable mode of testing for Tomcat, as this provides the quickest turn-around time, and worry-free. This mode is the only mode in Tomcat where you can use a single debug session to debug both the client and the server.              
    <a name="Remote_Tomcat"></a>
    <h5>
      <a name="Remote_Tomcat">
        <a href="#Remote_Tomcat">1.4.2.2.</a>  Remote Tomcat
      </a>
    </h5>   
    <p>The following command causes tests to run by using Tomcat launched externally. The parameter to the -tomcat-remote option is
      <tt>
        <i>adminUserName</i>:
        <i>adminPassword</i>@
        <i>hostname</i>:
        <i>port</i>
      </tt>.
      
    <pre class="cmd">$ java -jar path/to/harness.jar -tomcat-remote admin:admin@localhost:8080 test-dir1 test-dir2 ...</pre>  
    <p>It is your responsibility to launch Tomcat. In this mode, the harness will only deploy and undeploy services from this running instance. The tomcat used for this purpose should
      <b>NOT</b> have JAX-WS/Tango binaries installed in
      <tt>common/lib</tt> or anywhere else. The harness will include everything necessary into a war file, and this is the only way to make sure that you are testing the bits that you are supposed to be testing.
      
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> To find out the admin username and password, look at
            <tt>$TOMCAT_HOME/conf/tomcat-users.xml</tt> and find the entry that has "manager" as one of the roles. If none is found, simply add the following two lines to the file:
            <pre>
&lt;role rolename="manager"/&gt;
&lt;user username="admin" password="admin" roles="manager"/&gt;
</pre>  
          </td> 
        </tr>
      </table> 
    </div>   
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> To debug the server side in this set up, you need to launch Tomcat with the debugger support enabled. Run
            <tt>catalina.sh jpda run</tt> to do this, and you can attach your debugger to Tomcat remotely. 
          </td> 
        </tr>
      </table> 
    </div>   
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> (Tomcat 5.0.x only) By default, Tomcat is configured to output logs to multiple places, including files in the
            <tt>logs</tt> directory and stdout/stderr. This is often inconvenient for debugging, as you are not sure which file you should monitor. You can modify
            <tt>$TOMCAT_HOME/conf/server.xml</tt> to avoid this problem, by sending all the outputs to stdout. To do so, find all "&lt;Logger&gt;" elements in server.xml and replace them with
            <tt>SystemOutLogger</tt>, like this:
            <pre>&lt;Logger className="org.apache.catalina.logger.SystemOutLogger" /&gt;</pre>  
          </td> 
        </tr>
      </table> 
    </div>   
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> When tests are aborted via Ctrl+C, web applications may be left running on this remote machine. When the test is run next time, they will be removed (or you can remove them manually.) </td> 
        </tr>
      </table> 
    </div>               
    <a name="Local_Tomcat"></a>
    <h5>
      <a name="Local_Tomcat">
        <a href="#Local_Tomcat">1.4.2.3.</a>  Local Tomcat
      </a>
    </h5>   
    <p>Run the following command to use Tomcat in the local mode. In this mode, the haress launches Tomcat as a child process, run tests, and terminates Tomcat when everything is done.  
    <pre class="cmd">$ java -jar path/to/harness.jar -tomcat-local path/to/tomcat test-dir1 test-dir2 ...</pre>  
    <p>See the tips for the remote tomcat support for how to configure Tomcat to report logs to one place.  
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> On Windows systems, aborting the harness via Ctrl+C will leave the child Tomcat process running (does anyone know how to fix that?) Those orphan processes can be killed from task manager (be careful not to kill other Java processes), or better yet,
            <a href="http://www.sysinternals.com/Utilities/ProcessExplorer.html">process explorer</a>. 
          </td> 
        </tr>
      </table> 
    </div>                    
    <a name="Jetty"></a>
    <h4>
      <a name="Jetty">
        <a href="#Jetty">1.4.3.</a>  Jetty
      </a>
    </h4>   
    <p>This test harness supports Jetty 6.x.         
    <a name="Embedded_Jetty"></a>
    <h5>
      <a name="Embedded_Jetty">
        <a href="#Embedded_Jetty">1.4.3.1.</a>  Embedded Jetty
      </a>
    </h5>   
    <p>The following command causes the harness to run Jetty within the same VM. See the embedded tomcat description for more about what it means to embed a container.  
    <pre class="cmd">$ java -jar path/to/harness.jar -jetty-embedded path/to/jetty-6.1.0 test-dir1 test-dir2 ...</pre>                    
    <a name="Glassfish"></a>
    <h4>
      <a name="Glassfish">
        <a href="#Glassfish">1.4.4.</a>  Glassfish
      </a>
    </h4>   
    <p>This test harness supports Glassfish 1.0.         
    <a name="Remote_Glassfish"></a>
    <h5>
      <a name="Remote_Glassfish">
        <a href="#Remote_Glassfish">1.4.4.1.</a>  Remote Glassfish
      </a>
    </h5>   
    <p>To test with existing instance of Glassfish, use the following option. This mode assumes that you have already started a domain, and the harness will simply deploy/undeploy applications to this running service:  
    <pre class="cmd">$ java -jar path/to/harness.jar -glassfish-remote localhost test-dir1 test-dir2 ...</pre>  
    <p>The "-glassfish-remote" takes the connection string as the parameter. The full syntax of the paramter is
      <tt>[USER:PASS@]HOST[:PORT][-HTTPURL]</tt>. The first four parts up to '-' specifies the Glassfish admin port. USER and PASS is used for the administrator login, and PORT is the admin TCP port. The last HTTPURL specifies the URL with which client test programs talk to the service. All components but HOST are defaulted, so if your glassfish installation is out of the box, then all you need to specify is the host name where Glassfish runs.
      
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> Glassfish has its copy of JAX-WS, so testing with Glassfish requires us to replace the runtime of Glassfish. At this point the harness is not capable of doing that. </td> 
        </tr>
      </table> 
    </div>               
    <a name="Local_Glassfish"></a>
    <h5>
      <a name="Local_Glassfish">
        <a href="#Local_Glassfish">1.4.4.2.</a>  Local Glassfish
      </a>
    </h5>   
    <p>The test harness is capable of starting and stopping Glassfish on its own before/after running tests. This mode assumes that you have Glassfish installed locally. Use the following command line option to run in this mode:  
    <pre class="cmd">$ java -jar path/to/harness.jar -glassfish-local path/to/glassfish test-dir1 test-dir2 ...</pre>  
    <p>The harness will create a domain configuration in a temporary directory and run tests from there, so this running mode will not touch the files in
      <tt>path/to/glassfish</tt> --- it is simply used to load jar files. All the TCP ports are chosen randomly from 20000-50000 ranges, to avoid collisions with other tests that happen to be running on the same machine. See the console output for the HTTP port and admin port, in case you need to manually access them for debugging. The admin user name and password will be set to "admin" and "adminadmin" respectively.
    
    <p>This mode is convenient for fully automated Glassfish testing, because you do not need a dedicated Glassfish installation per each test set up, and the harness chooses the right TCP ports to avoid conflicts. However, starting and stopping Glassfish takes significant amount of time, so it's almost impossible to use for interactive debugging.                        
    <a name="Running_Batch_Tests"></a>
    <h3>
      <a name="Running_Batch_Tests">
        <a href="#Running_Batch_Tests">1.5.</a>  Running Batch Tests
      </a>
    </h3>   
    <p>There are a few command-line options that often go with automated batch test for a large number of tests. First, use
      <tt>-p N</tt> to run tests by using N number of threads. This should be used on a multi-processor system to reduce the turn-around time of the test, and therefore ideal for continuous testing.
                 
    <a name="Summarizing_Test_Results"></a>
    <h3>
      <a name="Summarizing_Test_Results">
        <a href="#Summarizing_Test_Results">1.6.</a>  Summarizing Test Results
      </a>
    </h3>   
    <p>The
      <tt>-report DIR</tt> option causes the harness to generate JUnit test report files into the specified directory. This allows the reports to be combined with other JUnit or TestNG-based tests (such as per-class unit test.) These XML reports can be then formatted into HTML (via &lt;junitreport&gt; ant task) or picked up by Hudson for further processing.
                 
    <a name="Generating_Coverage_Report"></a>
    <h3>
      <a name="Generating_Coverage_Report">
        <a href="#Generating_Coverage_Report">1.7.</a>  Generating Coverage Report
      </a>
    </h3>   
    <p>The test harness can generate
      <a href="http://emma.sourceforge.net/">EMMA</a> coverage report of the tests by specifying the
      <tt>-emma OUTPUTFILE</tt> option. The coverage will include both the runtime as well as tools. See
      <a href="http://emma.sourceforge.net/userguide/ar01s02s03.html">Emma User's Guide</a> for how to generate various reports from the coverage data file.
                      
    <a name="Writing_Tests"></a>
    <h2>
      <a name="Writing_Tests">
        <a href="#Writing_Tests">2.</a>  Writing Tests
      </a>
    </h2>           
    <a name="Conventions"></a>
    <h3>
      <a name="Conventions">
        <a href="#Conventions">2.1.</a>  Conventions
      </a>
    </h3>   A single end-to-end test consists of a client talking to services. Each test is organized into one directory. A test directory could look like the following:
    <pre class="dir">
testdir/
 +- test-descriptor.xml     (metadata file that describes a test)
 +- custom-client.xml       (optional client customization file)
 +- *.bsh                   (client test scripts)
 +- common/                 (optional common source files)
 |   +- *.java
 +- client/                 (optional client source files)
 |   +- *.java
 +- resources/              (optional resource files if needed by test)
 |   +- mascot.jpeg
 +- AddNumbers.wsdl         (optional WSDL that represents service)
 +- **/*.java               (Java code that implements service)
 +- web.xml                 (optional web.xml file, if specified used for packaging the war)     
</pre>              
    <a name="Test_Descriptor"></a>
    <h3>
      <a name="Test_Descriptor">
        <a href="#Test_Descriptor">2.2.</a>  Test Descriptor
      </a>
    </h3>   
    <p>The file
      <TT>test-descriptor.xml</TT> is the heart of the test data, and it contains the required configuration information for each test. A typical "fromwsdl" test descriptor could look like the following:
     
    <pre>
&lt;descriptor&gt;
   &lt;description&gt;this is a very useful test that tests stuff&lt;/description&gt; 
   &lt;client href="*.bsh"/&gt;
   &lt;service&gt;
     &lt;wsdl href="AddNumbers.wsdl"/&gt;
   &lt;/service&gt;
&lt;/despcriptor&gt;
</pre> 
    <p>The structure of the test descriptor is defined in
      <a href="test-descriptor.rnc">a schema</a>, and the harness performs an XML validation to make sure the data is in the expected format.
             
    <a name="Linking_to_Relevant_Bugs"></a>
    <h4>
      <a name="Linking_to_Relevant_Bugs">
        <a href="#Linking_to_Relevant_Bugs">2.2.1.</a>  Linking to Relevant Bugs
      </a>
    </h4>   
    <p>It is recommended that you link test cases to relevant bugs, so that in the future we can take advantage of information programatically. To do this, use the bugs attribute on the descriptor element. It takes whitespace-separated list of bugs,where each of them are either 7-digit bugster ID or a java.net proeject name followed by an issue number. 
    <pre>
&lt;descriptor bugs="6420352 wsit-123 jax-ws-234"&gt;
  ...
&lt;/descriptor&gt;
</pre>              
    <a name="Specifying_test_requirements_from_the_Container"></a>
    <h4>
      <a name="Specifying_test_requirements_from_the_Container">
        <a href="#Specifying_test_requirements_from_the_Container">2.2.2.</a>  Specifying test requirements from the Container
      </a>
    </h4>   
    <p>If your test relies on a certain capability from the container, Specify such requirements in "uses" attribute. Harness checks the capabilities of the container to continue with running the test or skipping it. Supported values are "servlet30", "servlet","ri","multi-endpoint","skip-lwhs". 
    <p>Please use this option with caution, so that tests can retain its generality. 
    <pre>
&lt;descriptor uses="servlet30"&gt;
    &lt;description&gt;this test runs only on servlet 3.0 based container&lt;/description&gt;
    ....
&lt;/despcriptor&gt;
      </pre>              
    <a name="Specifying_verbatim_wsimport_options"></a>
    <h4>
      <a name="Specifying_verbatim_wsimport_options">
        <a href="#Specifying_verbatim_wsimport_options">2.2.3.</a>  Specifying verbatim wsimport options
      </a>
    </h4>   
    <p>If your test requires a certain wsimport command line options, you can specify verbatim by using the nested
      <tt>wsimport-client</tt> and
      <tt>wsimport-server</tt> elements. These are passed as-is to when the harness invokes wsimport for generating client artifacts and generating server artifacts, respectively. Options can be separated by tab, space, CR, and NL.
    
    <p>Please use this option with caution, so that tests can retain its generality. 
    <pre>
&lt;descriptor&gt;
   &lt;description&gt;this is a very useful test that tests stuff&lt;/description&gt;
   &lt;wsimport-client&gt;-abc -def -ghi&lt;/wsimport-client&gt;
&lt;/despcriptor&gt;
</pre>              
    <a name="Specifying_test_specific_options"></a>
    <h4>
      <a name="Specifying_test_specific_options">
        <a href="#Specifying_test_specific_options">2.2.4.</a>  Specifying test specific options
      </a>
    </h4>   
    <p>If your test special configuration from the default harness behavior,
      <tt>test-options</tt> is the place to specify those.
      <pre>Supported Options are:
    -noPackage : to not use the default harness behavior of specifying -p option to wsimport.</pre> 
      <pre>
&lt;descriptor&gt;
   &lt;description&gt;this is a very useful test that tests stuff&lt;/description&gt;
   &lt;test-options&gt;-noPackage&lt;/test-options&gt;
&lt;/despcriptor&gt;
</pre> 
                      
    <a name="Client_Test_Scripts"></a>
    <h3>
      <a name="Client_Test_Scripts">
        <a href="#Client_Test_Scripts">2.3.</a>  Client Test Scripts
      </a>
    </h3>   
    <p>Client test scripts are the programs that are executed after all the services are set up. These scripts are expected to make some service invocations and perform assretions. Test scripts can be written as:
      <ul>
        <li>files. They can be anywhere and have any name, since the harness locates them through
          <tt>&lt;client href="..."&gt;</tt> inside the descriptor. However, we recommend keeping them at the top directory and use ".bsh" suffix.
        </li>
        <li>Inline inside the test descriptor, as illustrated below. This is particularly convenient for small test clients. The name attribute indicates human readable short summary of a test:
          <pre>
&lt;descriptor&gt;
  &lt;description&gt;this is a very useful test that tests stuff&lt;/description&gt; 
  &lt;client name="echo test"&gt;
    assertEquals("hello",fooPort.echo("hello"));
  &lt;/client&gt;
  ...
&lt;/descriptor&gt;
</pre> 
        </li>
      </ul> 
    
    <p>Scripts are written in the
      <a href="http://www.beanshell.org">Beanshell</a> scripting language. BeanShell is mostly compatible with Java, so you can write any valid Java programs, such as:
      
    <pre class="script">
import java.math.*;
BigInteger bi = new BigInteger("35.12");
</pre>  
    <p>As a scripting language, BeanShell allows you to save typing. Specifically,
      <ol>
        <li>You need not perform any explicit casting, since variables are not statically typed.</li>
        <li>No explicit variable declaration is required (although allowed)</li>
        <li>Auto-boxing/unboxing ala Tiger</li>
        <li>Type parameters are not needed (in fact they are not supported)</li>
      </ol> 
    
    <p>So you can write a program like this: 
      <pre class="script">
import java.math.*;
bi = new Holder(new BigInteger("35.12")); // create JAX-WS holder object with BigInteger
</pre>  
    
    <p>See
      <a href="http://www.beanshell.org/manual/syntax.html">beanshell syntax documentation</a> for more about BeanShell syntax.
             
    <a name="Invoking_Services"></a>
    <h4>
      <a name="Invoking_Services">
        <a href="#Invoking_Services">2.3.1.</a>  Invoking Services
      </a>
    </h4>   
    <p>To isolate the tests from the environment, and to make tests as reusable as possible, the harness creates services and port objects on behalf of the test programs. This allows the harness to configure ports correctly, so that they can talk to the right service.
    <p>For this reason, it's important for the client program not to create port objects on its own. See the following illustration: 
      <pre class="script">
// :-&lt; BAD EXAMPLE
port = new HelloService().getHelloPort();
port.sayHelloTo("duke");

// :-) GOOD EXAMPLE
helloPort.sayHelloTo("duke");
</pre>  
    
    <p>To find out what port variables are imported under what names, check the output from the test harness. Right before the client script executes, you should see a line like this:
      <pre>injected services: helloService</pre> 
      <pre>injected ports: addNumbersPort</pre> 
    
    <p>The only exception to this "don't create your ports" rule is when you need
      <tt>Dispatch</tt> objects, where you'd need to use the pre-defined variable "Address", for ex: helloPortAddress 
      <span style="color:red; font-weight:bold">(not fully cooked. Feedback welcome)</span>  :
    
    <p>Junit based tests can use System property to access the endpoint address, for ex: System.getProperty("helloPortAddress")  
    <pre class="script">
// create dispatch
helloService.addPort(new QName("foo","bar"), jakarta.xml.ws.soap.SOAPBinding.SOAP11HTTP_BINDING, endpointAddress);
</pre>               
    <a name="More_on_Script_Execution_Environment"></a>
    <h4>
      <a name="More_on_Script_Execution_Environment">
        <a href="#More_on_Script_Execution_Environment">2.3.2.</a>  More on Script Execution Environment
      </a>
    </h4>   
    <p>For productivity, scripts are run in a configured environment. Client scripts are expected to take advantage of those.
      <ol>
        <li>Script can invoke any of the
          <a href="http://www.junit.org/junit/javadoc/3.8.1/junit/framework/Assert.html">
            <tt>junit.framework.Assert</tt>
          </a> methods without any qualifier. So you can just write
          <tt>assertEquals(5,3+2)</tt>. This is the prefered way of testing assertions.
        </li>
        <li>The following Java packages are implicitly imported.
          <ul>
            <li>java.lang</li>
            <li>java.util</li>
            <li>java.util.cocurrent</li>
            <li>jakarta.xml.soap</li>
            <li>jakarta.xml.ws</li>
            <li>jakarta.xml.ws.soap</li>
            <li>jakarta.xml.bind</li>
            <li>javax.xml.namespace</li>
            <li>javax.xml.transform</li>
            <li>javax.xml.transform.sax</li>
            <li>javax.xml.transform.dom</li>
            <li>javax.xml.transform.stream</li>
            <li>(client artifact packages)</li>
          </ul> So you could just say
          <tt>JAXBContext.newInstance(...)</tt> instead of
          <tt>jakarta.xml.bind.JAXBContext.newInstance(...)</tt>. Client artifact packages are all imported, too, so for example if you need to create a bean for service invocation, you can do as follows:
          <pre class="script">
bean = new FooBarBean(); // instead of new test.fromwsdl.helloLit.client.FooBarBean();
bean.setName("Duke");
bean.setId(53);
</pre>  
        </li>
        <li>Helper methods. The harness defines a few helper methods that are avaialble to the script as if they are global functions. See
          <a href="http://kohsuke.sfbay/hudson/job/jaxws-test-harness/ws/src/com/sun/xml/ws/test/client/ScriptBaseClass.java">this source code</a> and
          <a href="http://kohsuke.sfbay/hudson/job/jaxws-test-harness/ws/src/com/sun/xml/ws/test/exec/util.bsh">this source code</a> for the complete list and their semantics.
        </li>
      </ol> 
                 
    <a name="Common_utility"></a>
    <h4>
      <a name="Common_utility">
        <a href="#Common_utility">2.3.3.</a>  Common utility
      </a>
    </h4>   
    <p>Often it's useful to factor out the common variable/function/etc for multiple &lt;client&gt; scripts in a single test suite. This can be done by defining &lt;pre-client&gt; element in the test descriptor. If specified, the pre-script will be executed before each client test script is executed.             
    <a name="Side_effect_free_tests"></a>
    <h4>
      <a name="Side_effect_free_tests">
        <a href="#Side_effect_free_tests">2.3.4.</a>  Side-effect free tests
      </a>
    </h4>   
    <p>Many tests are written in such a way that they do not have any side-effect on both server or client (when I say side-effect, I mean things like updating global counters or touching database or anything of that sort.) Test descriptor can mark those tests as "side-effect free" by adding the attribute as follows: 
    <pre>
&lt;descriptor&gt;
...
&lt;client href="abc.bsh" sideEffectFree="true" /&gt;
&lt;/descriptor&gt;
</pre> 
    <p>With the '-concurrent-side-effect-free' option, tests marked in this way will be run in concurrent environment. That is to say, the same test will be run repeatedly in multiple threads. This allows the runtime to be exercised in a new way.                   
    <a name="Java_Client"></a>
    <h3>
      <a name="Java_Client">
        <a href="#Java_Client">2.4.</a>  Java Client
      </a>
    </h3>   
    <p>If your client test scripts need some Java helper code (such as handlers), or if you have some JUnit test classes written as Java classes, you can put them under the
      <tt>testdir/client</tt> directory. All classes that ends with "Test" will be considered JUnit tests and executed like client test scripts.
    
    <p>Also, all the Java source files are compiled and made available to client test scripts (for example so that you can access those classes.) The "client" package itself will be also imported into the client test scripts, so classes in the "client" package can be accessed by their short name.             
    <a name="Service"></a>
    <h3>
      <a name="Service">
        <a href="#Service">2.5.</a>  Service
      </a>
    </h3>   
    <p>Code that constitutes a service needs to be written by using Java. By default, those files should be placed into the same test directory. If you are converting existing test services to this harness, most likely the only thing that needs to change is the declared package name.
    <p>In a rare circumstance, where you need multiple independently deployed services, you can use
      <TT>&lt;service basedir="..."/&gt;</TT> value to move service source files into subdirectories to isolate them.
      
    <div class="tip">
      <table>
        <tr>
          <td>
            <img src="tip.png"> 
          </td>
          <td> To set a binding in fromjava scenarios, use the
            <tt>jakarta.xml.ws.BindingType</tt> annotation on your service class. For example,
            <pre>
@WebService
@BindingType(SOAPBinding.SOAP11HTTP_BINDING)
class FooBarSgervice {
  ...
}
</pre>  
          </td> 
        </tr>
      </table> 
    </div>          
    <a name="WSDL"></a>
    <h4>
      <a name="WSDL">
        <a href="#WSDL">2.5.1.</a>  WSDL
      </a>
    </h4>   
    <p>For scenarios which requiring building the service from a WSDL, there is a sub-element of service named
      <TT>wsdl</TT> with has an attribute named
      <TT>href</TT>.
      <TT>href</TT> should name the WSDL file, relative to the service's
      <TT>basedir</TT>.
    
    <p>When present, WSDL is first complied and then the artifacts are compiled together with the rest of the Java source files. The harness uses the
      <tt>-p</tt> option of wsimport to place the generated artifacts into the "right" package (infered from the directory name of the service.)
    
    <p>To further customize the compilation process, place a JAX-WS customization file named
      <tt>custom-server.xml</tt> to the service top directory (to refer to WSDL file and schema files from this customization file, just use the relative path from the customization file to WSDL/schemas like
      <tt>"./foo.xsd"</tt>.) You can also use
      <tt>custom-schema-server.xml</tt> to specify additional JAXB customization file.
                      
    <a name="Requiring_certain_modes"></a>
    <h3>
      <a name="Requiring_certain_modes">
        <a href="#Requiring_certain_modes">2.6.</a>  Requiring certain modes
      </a>
    </h3>   
    <p>A test can declare that it requires a particular kind of a transport by declaring the transport attribute. The possible values are the values you specify in the scheme portion of the endpoint address URI (The major values include "http" and "local", but open-ended as new transports are added.)
      <pre>
&lt;descriptor transport="http"&gt;
  ...
</pre> 
    
    <p>A test can also declare that it's applicable only to a certain verion(s) of JAX-WS/WSIT, by using the version attributes
      <tt>@since</tt>,
      <tt>@until</tt>, and
      <tt>@excludeFrom</tt>.
      <ol>
        <li>The @since attribute indicates that a test will require the given version of the test subject or later. For example,
          <tt>since="2.0"</tt> indicates that it will run on 2.0 FCS, 2.0 EAs, etc, but not on 1.1.
        </li>
        <li>The @until attribute indicates that a test can only be run against the given version of the test subject or earlier. For example
          <tt>until="1.*"</tt> indicates that the test will run on all versions of 1.x but not on 2.0.
        </li>
        <li>The @excludeFrom takes a list of whitespace-separated version numbers, and it indicates that tests be excluded from these specific versions. This is used to mark known regressions and such things.</li>
      </ol> 
    
    <p>Those three attributes can be combined, and they can be specified either on &lt;descript&gt; element (in which case the entire test is subject to the constraints), or on individual &lt;client&gt; element (in which case only that client test is subject to the constraints.)
    <p>See
      <a href="https://istack-commons.dev.java.net/source/browse/istack-commons/istack-commons/test/src/com/sun/istack/test/VersionNumber.java?only_with_tag=HEAD&amp;view=markup">this document</a> for more formal definition of what can be a valid version number, and how they are ordered.
    
    <p>Similarly, Junit based tests can specify version requirements by using annotation @com.sun.xml.ws.test.VersionRequirement(since="2.1.*", until="2.2",excludeFrom="") on the TestClass.              
    <a name="Resources"></a>
    <h3>
      <a name="Resources">
        <a href="#Resources">2.7.</a>  Resources
      </a>
    </h3>   
    <p>If test programs need to use image files, binary files, or other data files, they should be put in
      <TT>resources</TT> directory at test's top-level. This is optional. Those resources can be loaded by using the helper methods as follows: 
      <pre class="script">
File f = resource("foo.jpg");  // load resources/foo.jpg
</pre>  
    
    <p>For resources that are XML, you can define them by using &lt;xml-resource&gt; elements. 
    <pre>
&lt;!-- define it inline --&gt;
&lt;xml-resource name="foo"&gt;
  &lt;echoRequest&gt;123&lt;/echoRequest&gt;
&lt;/xml-resource&gt;

&lt;!-- define it externally --&gt;
&lt;xml-resource name="bar" href="my.xml" /&gt;
</pre> 
    <p>Such XML resources are injected into clients as variables of the type
      <a href="http://kohsuke.sfbay/hudson/job/jaxws-test-harness/ws/src/com/sun/xml/ws/test/client/XmlResource.java">
        <tt>XmlResource</tt>
      </a>, so you can use them like this:
      
    <pre class="script">
echoPort.echoString(foo.asString());
</pre>               
    <a name="Common_source_files"></a>
    <h3>
      <a name="Common_source_files">
        <a href="#Common_source_files">2.8.</a>  Common source files
      </a>
    </h3>   
    <p>If test programs need to share some Java source files between the server and the client, those files can be put into the 'common' directory. They will be compiled and made available to both client and server.
    <p> 
      <span style="color:red; font-weight:bold">(not fully cooked. Feedback welcome)</span>  we are hoping to define more convenience methods and define how to access resources from server.
                      
    <a name="Technical_Assistance"></a>
    <h2>
      <a name="Technical_Assistance">
        <a href="#Technical_Assistance">3.</a>  Technical Assistance
      </a>
    </h2>   
    <p>Talk to Ken, Bhakti, Bobby, or Kohsuke if you have technical problems with the harness and need in-person assistance.
    <p>We use
      <a href="http://ws-test-harness.dev.java.net/">the java.net ws-test-harness project</a> for developing the harness. We use the
      <tt>dev@ws-test-harness.dev.java.net</tt> alias and the SWAN IRC
      <tt>#ws-test-harness</tt> for communication.
    
    <p>Our goal is to improve your developer productivity. Please use
      <a href="https://ws-test-harness.dev.java.net/issues/">the issue tracker</a> for keeping track of RFEs and problems.
           
  </body>
</html>
